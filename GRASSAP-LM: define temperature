#A constructive and improvement heuristic

rm(list=ls())
load(file="X65.RData")

##########################
#  Parameter definition  #
##########################
  
  #Save X and I to latter load to the original state
  XO <- X
  IO <- I

  #Loop repeat parameters
  NRepeats <- 10 #Number of repetitions

  #Constructive Heuristic parameters
  priority <- 5
  restriction <- 40

  #Improvement Heuristic parameters
  search_Magnitude <- 0.2
  imp_iteration <- 100
  รง <- 2
  penalty <- 2
  
  #Penalize Worst columns array for X
  X[,6] <- 0
  colnames(X)[6] <- "u"
  X[,7] <- 0
  colnames(X)[7] <- "I"
  for (i in 1:nrow(X)){
    X[i,7] <- length(which(AttComb[,i]==1))
  }
  Weight <- X[,3]
  
  #Help define temperature parameter
  Results <- matrix(0,nrow=imp_iteration,ncol=2) #1: Results X; 2: Results X1
  Delta <- matrix(0,nrow=NRepeats,ncol=3) #1: Cost of incumbent solution; 2: Cost of 3Q; 3: Absolute Difference

  

##########################
#      Loop Start        #
##########################
SysTime <- Sys.time()
for (lll in 1:NRepeats){
  
  #Reset to original state
  X[,c(2,6)] <- 0
  X[,3] <- Weight
  I[,2:3] <- 0
  
  

##########################
# Constructive Heuristic #
##########################

  #Create vectors to store info
  AST <- 0 #Attributes Selected total
  NSA <- c(1:nrow(I)) #Non Selected attributes
  SST <- 0 #Sets Selected total
  NSS <- c(1:nrow(X)) #Not Selected sets
  
  
  while( sum(I[,2])!=nrow(I) ){ #While not all attributes selected, continue
    
    #No. uncovered rows for set
    for (i in NSS){
      X[i,4] <- sum(AttComb[NSA,i])
    }
    
    #Calculate the priority rule for each relevant set
    RC <- sample(1:4,1) #Random cost (which one?)
    X[SST,5] <- Inf
    
    #Possible priority rules
    if (RC==1){
      X[NSS,5] <- X[NSS,3]  /  X[NSS,4] #c/k
    } else if (RC==2){
      X[NSS,5] <- X[NSS,3]  /  (X[NSS,4]^2) #c/k^2
    } else if (RC==3){
      X[NSS,5] <- (X[NSS,3])^(1/2)  /  X[NSS,4] #c^1/2k
    } else {
      X[NSS,5] <- X[NSS,3]  /  (X[NSS,4]^(1/2)) #c/k^1/2
    }
    
    W <- X[NSS,][which.min(X[NSS,5]),1] #Select set with lower cost
    
    
    if ( sample(1:100,1)>priority ){ #95% of the times will choose from CL and not the lowest cost
      CL <- X[ which(X[,5] <= X[W,5]*(1+restriction/100)  ) ,1] #Candidate List
      W <- CL[sample(length(CL),1)]
      
    }
    
    #Add selected set and cover its attributes
    #Select set
    X[W,2] = 1
    SST <- c(SST,W)
    NSS <- NSS[NSS!=W]
    
    #Select attributes
    AS <- which(AttComb[,W]==1) #Attributes satisfied by set W
    AST <- unique(c(AST,AS))
    NSA <- NSA[!NSA %in% AS]
    I[AS,2] = 1
    I[AS,3] = I[AS,3]+1
    
  }
  


#########################
# Remove redundant sets #
#########################

  RS <- c(0) #Redundant Sets
  
  while (length(RS)!=0){ #While there are redundant sets, continue
    
    #Necessary sets
    NS <- 0
    for (i in 1:nrow(I)) {
      if (I[i,3]==1){
        SS <- which(AttComb[i,]==1) #Sets that satisfy attribute i
        NS <- c(NS,  SS[SS %in% SST]  )
      }
    }
    NS <- unique(NS)
    
    #Redundant set
    RS <- SST[!SST %in% NS]
    RSMax <- X[RS,][which.max(X[RS,3]),1] #RS with the highest absolute cost
    
    
    X[RSMax,2] <- 0 #Deselect set
    SST <- SST[SST!=RSMax] #Remove set
    AR <- which(AttComb[,RSMax]==1) #Attributes affected by the removal of set RSMax
    I[AR,3] <- I[AR,3]-1 #Remove the "attribute selection" by the removed set
    RS <- RS[RS!=RSMax] #Remove RS from the RS vector
    
  }
  
  


###########################
# Help define Temperature #
###########################

  for (i in 1:imp_iteration){
    
    #Make copy of X and I to compute the parcial problem
    X1 <- X
    I1 <- I
    I1[,2:3] <- 0
    
    #Sets removal related
    R <- round(sum(X1[,2])*search_Magnitude) #Compute the number of sets to be removed
    SR <- sample(X1[X1[,2]==1,1],R) #Sets to be removed
    X1[SR,2] <- 0 #Deselect those sets
    SST <- X1[X1[,2]==1,1] #Sets Selected total
    NSS <- X1[X1[,2]==0,1] #Not Selected sets
    
    #Attribute adjustment related
    for (j in SST){  #Recompute which attributes are covered and how many times
      AS <- which(AttComb[,j]==1) #Attributes satisfied by set j
      I1[AS,2] <- 1
      I1[AS,3] <- I1[AS,3]+1
    }
    AST <- I1[I1[,2]==1,1] #Attributes Selected total
    NSA <- I1[I1[,2]==0,1] #Non Selected attributes
    
    
    
    ###############################
    # Compute the partial problem #
    ###############################

    while( sum(I1[,2])!=nrow(I) ){ #While not all attributes selected, continue
      
      #No. uncovered rows for set
      for (l in NSS){
        X1[l,4] <- sum(AttComb[NSA,l])
      }
      
      #Calculate the priority rule for each relevant set
      RC <- sample(1:4,1) #Random cost (which one?)
      X1[,5] <- Inf #Guarantee that only the sets in NSS can be selected
      
      #Possible priority rules
      if (RC==1){
        X1[NSS,5] <- X1[NSS,3]  /  X1[NSS,4] #c/k
      } else if (RC==2){
        X1[NSS,5] <- X1[NSS,3]  /  (X1[NSS,4]^2) #c/k^2
      } else if (RC==3){
        X1[NSS,5] <- (X1[NSS,3])^(1/2)  /  X1[NSS,4] #c^1/2k
      } else {
        X1[NSS,5] <- X1[NSS,3]  /  (X1[NSS,4]^(1/2)) #c/k^1/2
      }
      
      W <- X1[NSS,][which.min(X1[NSS,5]),1] #Select set with lower cost
      
      
      if ( sample(1:100,1)>priority ){ #95% of the times will choose from CL and not the lowest cost
        CL <- X1[ which(X1[,5] <= X1[W,5]*(1+restriction/100)  ) ,1] #Candidate List
        W <- CL[sample(length(CL),1)]
        
      }
      
      #Add selected set and cover its attributes
      #Select set
      X1[W,2] = 1
      SST <- c(SST,W)
      NSS <- NSS[NSS!=W]
      
      AS <- which(AttComb[,W]==1) #Attributes satisfied by set W
      AST <- unique(c(AST,AS))
      NSA <- NSA[!NSA %in% AS]
      I1[AS,2] = 1
      I1[AS,3] = I1[AS,3]+1
      
    }
    
    
    
    
    #########################
    # Remove redundant sets #
    #########################
    RS <- c(0) #Redundant Sets
    
    while (length(RS)!=0){ #While there are redundant sets, continue
      
      #Necessary sets
      NS <- 0
      for (o in 1:nrow(I)) {
        if (I1[o,3]==1){
          SS <- which(AttComb[o,]==1) #Sets that satisfy attribute o
          NS <- c(NS,  SS[SS %in% SST]  )
        }
      }
      NS <- unique(NS)
      
      #Redundant set
      RS <- SST[!SST %in% NS]
      RSMax <- X1[RS,][which.max(X1[RS,3]),1] #RS with the highest absolute cost
      
      
      X1[RSMax,2] <- 0 #Deselect set
      SST <- SST[SST!=RSMax] #Remove set
      AR <- which(AttComb[,RSMax]==1) #Attributes affected by the removal of set RSMax
      I1[AR,3] <- I1[AR,3]-1 #Remove the "attribute selection" by the removed set
      RS <- RS[RS!=RSMax] #Remove RS from the RS vector
      
    }
    
    
    
    print(paste("Loop",lll,"iteration no.",i))

    
    #Penalize the worst columns
    X1[,8] <- X1[,3]/X1[,6]*X1[,7]
    PenCost <- max(X1[X1[,2]==1,8]) * (1-penalty/100)   #Penalized Cost
    PL <- X1[X1[,2]==1,][which( X1[X1[,2]==1,8] >= PenCost ),1]
    X[PL,6] <- X[PL,6]+1  #Penalized List
    X[PL,3] <- X[PL,3] + ( รง * X[PL,3] * (1-exp(-X[PL,6]))  ) #Penalize worst columns (which are all at the first iteration)
    
    
    Results[i,1] <- sum(X[,2]*Weight)
    Results[i,2] <- sum(X1[,2]*Weight)
    
  }
  
  Delta[lll,1:2] <- c( Results[1,1] , quantile(Results[,2])[4] )
  Delta[lll,3] <- Delta[lll,1] - Delta[lll,2]
  
  
}

Temperature <- ( mean(Delta[,3]) / log(0.5,base = exp(1)) )
TimeTemp <- round(difftime(Sys.time(),SysTime,units="secs")[[1]],digits=4)


#Return to original state
X <- XO
I <- IO

rm(list=setdiff(ls(), c("AttComb","Delta","FR","I","SetComb","SO","Temperature","TimeTemp","X") ))

save.image(file="X65SADelta.RData")
